cat > main.py << 'EOF'
"""
高強度減重監測 LINE Bot
功能:
1. 接收食物照片,分析熱量與蛋白質
2. 記錄每日營養數據
3. 晚上23:00推播每日總結
"""

import os
import asyncio
import base64
from datetime import datetime, time
from typing import Optional
import logging

from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from linebot.v3 import WebhookHandler
from linebot.v3.exceptions import InvalidSignatureError
from linebot.v3.messaging import (
    Configuration,
    ApiClient,
    MessagingApi,
    ReplyMessageRequest,
    PushMessageRequest,
    TextMessage,
    ImageMessage
)
from linebot.v3.webhooks import (
    MessageEvent,
    TextMessageContent,
    ImageMessageContent
)
from openai import AsyncOpenAI
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from pydantic_settings import BaseSettings

from database import Database, MealRecord

# 設定日誌
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class Settings(BaseSettings):
    """環境變數設定"""
    LINE_CHANNEL_SECRET: str
    LINE_CHANNEL_ACCESS_TOKEN: str
    OPENAI_API_KEY: str
    
    class Config:
        env_file = ".env"


# 初始化設定
settings = Settings()
app = FastAPI(title="Diet Tracker LINE Bot")

# LINE Bot 設定
configuration = Configuration(access_token=settings.LINE_CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(settings.LINE_CHANNEL_SECRET)

# OpenAI 客戶端
openai_client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)

# 資料庫
db = Database()

# 排程器
scheduler = AsyncIOScheduler()


@app.on_event("startup")
async def startup_event():
    """應用啟動時初始化"""
    await db.init_db()
    
    # 設定每日 23:00 推播
    scheduler.add_job(
        daily_summary_push,
        'cron',
        hour=23,
        minute=0,
        id='daily_summary'
    )
    scheduler.start()
    logger.info("Bot 啟動成功,每日推播已設定")


@app.get("/")
async def root():
    """健康檢查端點"""
    return {"status": "ok", "message": "Diet Tracker Bot is running"}


@app.post("/webhook")
async def webhook(request: Request):
    """LINE Webhook 端點"""
    signature = request.headers.get('X-Line-Signature', '')
    body = await request.body()
    
    try:
        handler.handle(body.decode('utf-8'), signature)
    except InvalidSignatureError:
        raise HTTPException(status_code=400, detail="Invalid signature")
    
    return JSONResponse(content={"status": "ok"})


@handler.add(MessageEvent, message=TextMessageContent)
async def handle_text_message(event):
    """處理文字訊息"""
    user_id = event.source.user_id
    text = event.message.text.strip()
    
    # 指令處理
    if text in ["今日", "今日總計", "總計"]:
        summary = await get_daily_summary(user_id)
        reply_text = summary
    elif text in ["說明", "幫助", "help"]:
        reply_text = get_help_message()
    elif text == "清除今日":
        await db.delete_today_records(user_id)
        reply_text = "已清除今日所有記錄"
    else:
        reply_text = "請傳送食物照片讓我分析,或輸入「今日」查看總計"
    
    # 回覆訊息
    with ApiClient(configuration) as api_client:
        line_bot_api = MessagingApi(api_client)
        line_bot_api.reply_message(
            ReplyMessageRequest(
                reply_token=event.reply_token,
                messages=[TextMessage(text=reply_text)]
            )
        )


@handler.add(MessageEvent, message=ImageMessageContent)
async def handle_image_message(event):
    """處理圖片訊息 - 分析食物"""
    user_id = event.source.user_id
    message_id = event.message.id
    
    try:
        # 下載圖片
        with ApiClient(configuration) as api_client:
            line_bot_api = MessagingApi(api_client)
            image_content = line_bot_api.get_message_content(message_id)
            image_data = image_content
        
        # 轉換為 base64
        image_base64 = base64.b64encode(image_data).decode('utf-8')
        
        # 呼叫 GPT-5 Vision 分析
        analysis = await analyze_food_image(image_base64)
        
        # 儲存到資料庫
        await db.add_meal(
            user_id=user_id,
            calories=analysis['calories'],
            protein=analysis['protein'],
            food_description=analysis['description']
        )
        
        # 取得今日總計
        today_total = await db.get_today_total(user_id)
        
        # 組合回覆訊息
        reply_text = format_analysis_reply(analysis, today_total)
        
        # 回覆
        with ApiClient(configuration) as api_client:
            line_bot_api = MessagingApi(api_client)
            line_bot_api.reply_message(
                ReplyMessageRequest(
                    reply_token=event.reply_token,
                    messages=[TextMessage(text=reply_text)]
                )
            )
    
    except Exception as e:
        logger.error(f"圖片分析失敗: {e}")
        with ApiClient(configuration) as api_client:
            line_bot_api = MessagingApi(api_client)
            line_bot_api.reply_message(
                ReplyMessageRequest(
                    reply_token=event.reply_token,
                    messages=[TextMessage(text="分析失敗,請稍後再試")]
                )
            )


async def analyze_food_image(image_base64: str) -> dict:
    """使用 GPT-5 Vision 分析食物圖片"""
    try:
        response = await openai_client.chat.completions.create(
            model="gpt-5",  # 使用 GPT-5
            messages=[
                {
                    "role": "system",
                    "content": """你是專業的營養師。分析圖片中的食物,估算:
1. 總熱量(kcal)
2. 蛋白質含量(g)
3. 食物描述

請以 JSON 格式回覆:
{
  "calories": 數字,
  "protein": 數字,
  "description": "詳細食物內容"
}

估算要準確,考慮份量大小。"""
                },
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{image_base64}"
                            }
                        },
                        {
                            "type": "text",
                            "text": "請分析這份餐點的熱量與蛋白質"
                        }
                    ]
                }
            ],
            max_tokens=500,
            temperature=0.3
        )
        
        # 解析回應
        result_text = response.choices[0].message.content
        import json
        result = json.loads(result_text)
        
        return {
            "calories": float(result.get("calories", 0)),
            "protein": float(result.get("protein", 0)),
            "description": result.get("description", "未知食物")
        }
    
    except Exception as e:
        logger.error(f"GPT-5 分析錯誤: {e}")
        return {
            "calories": 0,
            "protein": 0,
            "description": "分析失敗"
        }


def format_analysis_reply(analysis: dict, today_total: dict) -> str:
    """格式化分析回覆訊息"""
    protein_progress = (today_total['protein'] / 300) * 100
    
    message = f"""本餐分析結果

食物內容:
{analysis['description']}

營養數據:
熱量: {analysis['calories']:.0f} kcal
蛋白質: {analysis['protein']:.1f} g

━━━━━━━━━━━━━━━
今日累計:
總熱量: {today_total['calories']:.0f} kcal
總蛋白質: {today_total['protein']:.1f} g / 300 g
達成率: {protein_progress:.1f}%

{get_progress_bar(protein_progress)}

{get_quick_tip(today_total['protein'])}"""
    
    return message


def get_progress_bar(percentage: float) -> str:
    """產生進度條"""
    filled = int(percentage / 10)
    bar = "█" * filled + "░" * (10 - filled)
    return f"[{bar}]"


def get_quick_tip(current_protein: float) -> str:
    """根據當前蛋白質提供建議"""
    remaining = 300 - current_protein
    
    if remaining <= 0:
        return "太棒了!已達成今日目標!"
    elif remaining <= 50:
        return f"再補充 {remaining:.0f}g 就達標囉!"
    elif remaining <= 100:
        return f"還需要 {remaining:.0f}g,可以吃一份雞胸肉(約50g蛋白質)"
    else:
        return f"還缺 {remaining:.0f}g,建議增加高蛋白食物攝取"


async def get_daily_summary(user_id: str) -> str:
    """取得每日總結"""
    today_total = await db.get_today_total(user_id)
    meals = await db.get_today_meals(user_id)
    
    if not meals:
        return "今日尚無記錄,開始拍照追蹤吧!"
    
    protein_progress = (today_total['protein'] / 300) * 100
    
    # 組合餐點清單
    meals_list = "\n".join([
        f"{i+1}. {m.food_description}\n   蛋白質 {m.protein:.1f}g  熱量 {m.calories:.0f}kcal"
        for i, m in enumerate(meals)
    ])
    
    summary = f"""今日營養總結

今日餐點:
{meals_list}

━━━━━━━━━━━━━━━
總計:
總熱量: {today_total['calories']:.0f} kcal
總蛋白質: {today_total['protein']:.1f} g / 300 g
達成率: {protein_progress:.1f}%

{get_progress_bar(protein_progress)}

{generate_gap_filler(today_total['protein'])}"""
    
    return summary


def generate_gap_filler(current_protein: float) -> str:
    """產生 Gap Filler 建議"""
    remaining = 300 - current_protein
    
    if remaining <= 0:
        return "恭喜達標!明天繼續保持!"
    
    suggestions = []
    
    # 雞胸肉 (每100g約31g蛋白質)
    if remaining >= 50:
        chicken_amount = int((remaining / 31) * 100)
        suggestions.append(f"雞胸肉 {chicken_amount}g (約{remaining/31*100/100:.0f}份)")
    
    # 乳清蛋白 (每份約25g)
    whey_servings = int(remaining / 25)
    if whey_servings > 0:
        suggestions.append(f"乳清蛋白 {whey_servings} 份")
    
    # 雞蛋 (每顆約6g)
    eggs = int(remaining / 6)
    if eggs > 0 and eggs <= 10:
        suggestions.append(f"雞蛋 {eggs} 顆")
    
    tip = f"""Gap Filler 建議 (還缺 {remaining:.0f}g):

可選擇以下任一補充:
{chr(10).join(f"• {s}" for s in suggestions)}

睡前記得補充!"""
    
    return tip


async def daily_summary_push():
    """每日 23:00 推播總結給所有用戶"""
    try:
        # 取得所有今日有記錄的用戶
        active_users = await db.get_active_users_today()
        
        with ApiClient(configuration) as api_client:
            line_bot_api = MessagingApi(api_client)
            
            for user_id in active_users:
                summary = await get_daily_summary(user_id)
                
                try:
                    line_bot_api.push_message(
                        PushMessageRequest(
                            to=user_id,
                            messages=[TextMessage(text=f"晚間總結\n\n{summary}")]
                        )
                    )
                    logger.info(f"推播成功: {user_id}")
                except Exception as e:
                    logger.error(f"推播失敗 {user_id}: {e}")
        
        logger.info(f"每日推播完成,共 {len(active_users)} 位用戶")
    
    except Exception as e:
        logger.error(f"每日推播錯誤: {e}")


def get_help_message() -> str:
    """說明訊息"""
    return """使用說明

主要功能:
1. 拍照上傳食物照片
   自動分析熱量與蛋白質

2. 輸入「今日」或「總計」
   查看今日營養數據

3. 每晚 23:00 自動推播
   提供每日總結與建議

其他指令:
- 清除今日 - 刪除今日所有記錄
- 說明 / help - 顯示此訊息

目標: 每日蛋白質 300g
加油!"""


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
EOF



